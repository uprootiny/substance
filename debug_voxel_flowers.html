<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîß Debug: Voxel Flower Diagnosis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r160/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.20.0/cannon.min.js"></script>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
        }

        .debug-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 100vh;
        }

        .debug-panel {
            border: 1px solid #0f0;
            padding: 15px;
            background: rgba(0, 255, 0, 0.05);
            overflow-y: auto;
        }

        .debug-panel h2 {
            color: #ff6b6b;
            margin-top: 0;
        }

        #canvas-container {
            width: 100%;
            height: 400px;
            border: 1px solid #0f0;
            margin: 10px 0;
        }

        button {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 10px;
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
        }

        button:hover {
            background: rgba(0, 255, 0, 0.2);
        }

        .log-entry {
            font-size: 12px;
            margin: 2px 0;
            padding: 2px 5px;
            border-left: 2px solid #333;
        }

        .log-error { border-left-color: #f00; color: #faa; }
        .log-success { border-left-color: #0f0; color: #afa; }
        .log-info { border-left-color: #00f; color: #aaf; }
        .log-warning { border-left-color: #fa0; color: #ffa; }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        .stat-item {
            padding: 5px;
            border: 1px solid #333;
            text-align: center;
        }

        pre {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border: 1px solid #333;
            overflow-x: auto;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <h1>üîß Voxel Flower Debug Console</h1>
    
    <div class="debug-container">
        <div class="debug-panel">
            <h2>üå∏ Renderer Test</h2>
            <div id="canvas-container"></div>
            
            <div>
                <button onclick="debugger.testBasicRendering()">Test Basic Rendering</button>
                <button onclick="debugger.testSingleVoxel()">Test Single Voxel</button>
                <button onclick="debugger.testFlowerGeneration()">Test Flower Generation</button>
                <button onclick="debugger.testPhysics()">Test Physics</button>
                <button onclick="debugger.clearAll()">Clear All</button>
            </div>
            
            <div class="stats-grid">
                <div class="stat-item">
                    <strong>Voxels:</strong> <span id="voxelCount">0</span>
                </div>
                <div class="stat-item">
                    <strong>Physics Bodies:</strong> <span id="physicsCount">0</span>
                </div>
                <div class="stat-item">
                    <strong>Scene Children:</strong> <span id="sceneCount">0</span>
                </div>
                <div class="stat-item">
                    <strong>Flowers:</strong> <span id="flowerCount">0</span>
                </div>
            </div>
        </div>
        
        <div class="debug-panel">
            <h2>üìä Debug Log</h2>
            <div>
                <button onclick="debugger.clearLog()">Clear Log</button>
                <button onclick="debugger.exportLog()">Export Log</button>
                <button onclick="debugger.runFullDiagnostic()">Full Diagnostic</button>
            </div>
            <div id="debug-log"></div>
            
            <h3>üîç System Info</h3>
            <pre id="system-info"></pre>
            
            <h3>‚öôÔ∏è Configuration</h3>
            <pre id="config-info"></pre>
        </div>
    </div>

    <script>
        class VoxelFlowerDebugger {
            constructor() {
                this.container = document.getElementById('canvas-container');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                
                // Physics world
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0);
                
                this.voxels = [];
                this.flowers = [];
                this.logEntries = [];
                
                this.init();
            }
            
            init() {
                this.log('üöÄ Initializing VoxelFlowerDebugger...', 'info');
                
                try {
                    this.setupRenderer();
                    this.setupCamera();
                    this.setupLighting();
                    this.setupPhysics();
                    this.startRenderLoop();
                    this.updateSystemInfo();
                    
                    this.log('‚úÖ Initialization complete', 'success');
                } catch (error) {
                    this.log(`‚ùå Initialization failed: ${error.message}`, 'error');
                    console.error('Initialization error:', error);
                }
            }
            
            setupRenderer() {
                const rect = this.container.getBoundingClientRect();
                this.renderer.setSize(rect.width, rect.height);
                this.renderer.setClearColor(0x111111);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                this.container.appendChild(this.renderer.domElement);
                this.log('üñ•Ô∏è Renderer setup complete', 'success');
            }
            
            setupCamera() {
                this.camera.position.set(5, 5, 5);
                this.camera.lookAt(0, 0, 0);
                this.camera.aspect = 1; // Square aspect for debug panel
                this.camera.updateProjectionMatrix();
                this.log('üì∑ Camera setup complete', 'success');
            }
            
            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                
                this.log('üí° Lighting setup complete', 'success');
            }
            
            setupPhysics() {
                // Ground plane
                const groundShape = new CANNON.Plane();
                const groundBody = new CANNON.Body({ mass: 0 });
                groundBody.addShape(groundShape);
                groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                groundBody.position.set(0, -1, 0);
                this.world.add(groundBody);
                
                this.log('‚ö° Physics setup complete', 'success');
            }
            
            testBasicRendering() {
                this.log('üß™ Testing basic rendering...', 'info');
                
                // Add a simple test cube
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
                const cube = new THREE.Mesh(geometry, material);
                cube.position.set(0, 0, 0);
                
                this.scene.add(cube);
                this.updateStats();
                
                this.log('‚úÖ Basic rendering test: Added test cube', 'success');
            }
            
            testSingleVoxel() {
                this.log('üß™ Testing single voxel creation...', 'info');
                
                try {
                    this.addVoxel(0, 0, 0, 0xff6b6b, 'test');
                    this.log('‚úÖ Single voxel test: Success', 'success');
                } catch (error) {
                    this.log(`‚ùå Single voxel test failed: ${error.message}`, 'error');
                }
            }
            
            testFlowerGeneration() {
                this.log('üß™ Testing flower generation...', 'info');
                
                const testTypes = ['quadruple', 'pentagonal', 'organic'];
                let successCount = 0;
                
                testTypes.forEach(type => {
                    try {
                        this.generateFlower(type);
                        successCount++;
                        this.log(`‚úÖ ${type} flower: Success`, 'success');
                    } catch (error) {
                        this.log(`‚ùå ${type} flower failed: ${error.message}`, 'error');
                    }
                });
                
                this.log(`üå∏ Flower generation test: ${successCount}/${testTypes.length} successful`, 
                         successCount === testTypes.length ? 'success' : 'warning');
            }
            
            testPhysics() {
                this.log('üß™ Testing physics integration...', 'info');
                
                try {
                    // Create a physics-enabled voxel
                    const voxel = this.addVoxel(0, 5, 0, 0x4ecdc4, 'physics-test');
                    
                    if (voxel && voxel.userData && voxel.userData.body) {
                        this.log('‚úÖ Physics test: Voxel has physics body', 'success');
                        
                        // Test physics stepping
                        let initialY = voxel.userData.body.position.y;
                        this.world.step(1/60);
                        
                        if (voxel.userData.body.position.y < initialY) {
                            this.log('‚úÖ Physics test: Gravity working', 'success');
                        } else {
                            this.log('‚ö†Ô∏è Physics test: Gravity not detected', 'warning');
                        }
                    } else {
                        this.log('‚ùå Physics test: No physics body created', 'error');
                    }
                } catch (error) {
                    this.log(`‚ùå Physics test failed: ${error.message}`, 'error');
                }
            }
            
            addVoxel(x, y, z, color, type) {
                const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const material = new THREE.MeshLambertMaterial({ 
                    color: typeof color === 'number' ? color : color.getHex() 
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.scene.add(mesh);
                
                // Add physics body
                const shape = new CANNON.Box(new CANNON.Vec3(0.1, 0.1, 0.1));
                const body = new CANNON.Body({ 
                    mass: type === 'stem' ? 0.2 : 0.05 
                });
                body.addShape(shape);
                body.position.set(x, y, z);
                this.world.add(body);
                
                // Link visual and physics
                mesh.userData = { body };
                
                this.voxels.push(mesh);
                this.updateStats();
                
                return mesh;
            }
            
            generateFlower(symmetryType) {
                const colors = {
                    quadruple: [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96ceb4],
                    pentagonal: [0xe17055, 0xfdcb6e, 0x6c5ce7, 0xa29bfe, 0xfd79a8],
                    organic: [0x00b894, 0x00cec9, 0x6c5ce7, 0xa29bfe, 0xfd79a8]
                };
                
                const palette = colors[symmetryType] || colors.organic;
                const flowerColors = palette.map(color => new THREE.Color(color));
                
                const center = new THREE.Vector3(
                    Math.random() * 4 - 2, 
                    0, 
                    Math.random() * 4 - 2
                );
                
                // Generate flower based on symmetry type
                switch(symmetryType) {
                    case 'quadruple':
                        this.createQuadrupleFlower(center, flowerColors);
                        break;
                    case 'pentagonal':
                        this.createPentagonalFlower(center, flowerColors);
                        break;
                    default:
                        this.createOrganicFlower(center, flowerColors);
                        break;
                }
                
                this.flowers.push({ 
                    type: symmetryType, 
                    time: Date.now(),
                    center: center,
                    voxelCount: this.voxels.length
                });
                this.updateStats();
            }
            
            createQuadrupleFlower(center, colors) {
                const stemHeight = 2 + Math.random() * 1;
                
                // Create stem
                for (let y = 0; y < stemHeight; y += 0.3) {
                    this.addVoxel(center.x, y, center.z, 0x2d5a27, 'stem');
                }
                
                // Create 4 branches
                for (let i = 0; i < 4; i++) {
                    const angle = (i * Math.PI * 2) / 4;
                    const branchLength = 1.5 + Math.random() * 0.5;
                    
                    for (let r = 0.3; r <= branchLength; r += 0.3) {
                        const x = center.x + Math.cos(angle) * r;
                        const z = center.z + Math.sin(angle) * r;
                        const y = stemHeight + Math.sin(r) * 0.3;
                        
                        const colorIndex = Math.floor(Math.random() * colors.length);
                        this.addVoxel(x, y, z, colors[colorIndex], 'petal');
                    }
                }
            }
            
            createPentagonalFlower(center, colors) {
                const stemHeight = 2 + Math.random() * 1;
                
                // Create stem
                for (let y = 0; y < stemHeight; y += 0.3) {
                    this.addVoxel(center.x, y, center.z, 0x2d5a27, 'stem');
                }
                
                // Create 5 petals
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const r = Math.sqrt(i) * 0.2;
                    
                    if (r < 1.5) {
                        const x = center.x + Math.cos(angle) * r;
                        const z = center.z + Math.sin(angle) * r;
                        const y = stemHeight + Math.sin(r * 2) * 0.2;
                        
                        const colorIndex = Math.floor((i / 3) % colors.length);
                        this.addVoxel(x, y, z, colors[colorIndex], 'petal');
                    }
                }
            }
            
            createOrganicFlower(center, colors) {
                const stemHeight = 2 + Math.random() * 1;
                
                // Create curved stem
                for (let y = 0; y < stemHeight; y += 0.3) {
                    const curve = Math.sin(y) * 0.1;
                    this.addVoxel(center.x + curve, y, center.z, 0x2d5a27, 'stem');
                }
                
                // Random organic petals
                const petalCount = 10 + Math.floor(Math.random() * 10);
                for (let i = 0; i < petalCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * 1.5 + 0.3;
                    const height = stemHeight + Math.random() * 1 - 0.5;
                    
                    const x = center.x + Math.cos(angle) * r;
                    const z = center.z + Math.sin(angle) * r;
                    
                    const colorIndex = Math.floor(Math.random() * colors.length);
                    this.addVoxel(x, height, z, colors[colorIndex], 'petal');
                }
            }
            
            clearAll() {
                this.log('üßπ Clearing all objects...', 'info');
                
                // Remove all voxels
                this.voxels.forEach(voxel => {
                    this.scene.remove(voxel);
                    if (voxel.userData.body) {
                        this.world.remove(voxel.userData.body);
                    }
                });
                
                // Clear non-lighting scene objects
                const objectsToRemove = [];
                this.scene.traverse((object) => {
                    if (object.type === 'Mesh' && object.material && !object.isLight) {
                        objectsToRemove.push(object);
                    }
                });
                
                objectsToRemove.forEach(obj => this.scene.remove(obj));
                
                this.voxels = [];
                this.flowers = [];
                this.updateStats();
                
                this.log('‚úÖ Clear complete', 'success');
            }
            
            runFullDiagnostic() {
                this.log('üîç Running full diagnostic...', 'info');
                this.clearAll();
                
                setTimeout(() => this.testBasicRendering(), 100);
                setTimeout(() => this.testSingleVoxel(), 500);
                setTimeout(() => this.testPhysics(), 1000);
                setTimeout(() => this.testFlowerGeneration(), 1500);
                setTimeout(() => {
                    this.log('üéØ Full diagnostic complete', 'success');
                    this.updateSystemInfo();
                }, 2500);
            }
            
            updateStats() {
                document.getElementById('voxelCount').textContent = this.voxels.length;
                document.getElementById('physicsCount').textContent = this.world.bodies.length;
                document.getElementById('sceneCount').textContent = this.scene.children.length;
                document.getElementById('flowerCount').textContent = this.flowers.length;
            }
            
            updateSystemInfo() {
                const info = {
                    'THREE.js Version': THREE.REVISION,
                    'WebGL Renderer': this.renderer.capabilities.isWebGL2 ? 'WebGL 2' : 'WebGL 1',
                    'Max Texture Size': this.renderer.capabilities.maxTextureSize,
                    'Physics Bodies': this.world.bodies.length,
                    'Scene Objects': this.scene.children.length,
                    'Canvas Size': `${this.renderer.domElement.width}x${this.renderer.domElement.height}`,
                    'Device Pixel Ratio': window.devicePixelRatio,
                    'User Agent': navigator.userAgent.substring(0, 50) + '...'
                };
                
                document.getElementById('system-info').textContent = 
                    Object.entries(info).map(([k, v]) => `${k}: ${v}`).join('\\n');
                
                const config = {
                    'Physics Gravity': this.world.gravity.toString(),
                    'Camera Position': `(${this.camera.position.x.toFixed(1)}, ${this.camera.position.y.toFixed(1)}, ${this.camera.position.z.toFixed(1)})`,
                    'Renderer Clear Color': '0x' + this.renderer.getClearColor().getHexString(),
                    'Shadow Map': this.renderer.shadowMap.enabled ? 'Enabled' : 'Disabled',
                    'Total Voxels Created': this.voxels.length,
                    'Total Flowers Created': this.flowers.length
                };
                
                document.getElementById('config-info').textContent = 
                    Object.entries(config).map(([k, v]) => `${k}: ${v}`).join('\\n');
            }
            
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const entry = `[${timestamp}] ${message}`;
                
                this.logEntries.push({ message: entry, type, timestamp });
                
                const logContainer = document.getElementById('debug-log');
                const logElement = document.createElement('div');
                logElement.className = `log-entry log-${type}`;
                logElement.textContent = entry;
                
                logContainer.appendChild(logElement);
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // Limit log entries
                if (this.logEntries.length > 100) {
                    this.logEntries.shift();
                    logContainer.removeChild(logContainer.firstChild);
                }
            }
            
            clearLog() {
                document.getElementById('debug-log').innerHTML = '';
                this.logEntries = [];
                this.log('üßπ Log cleared', 'info');
            }
            
            exportLog() {
                const logText = this.logEntries.map(entry => entry.message).join('\\n');
                const blob = new Blob([logText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `voxel-flower-debug-${Date.now()}.log`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.log('üìÑ Log exported', 'success');
            }
            
            startRenderLoop() {
                const animate = () => {
                    requestAnimationFrame(animate);
                    
                    // Update physics
                    this.world.step(1/60);
                    
                    // Sync visual objects with physics bodies
                    this.voxels.forEach(voxel => {
                        if (voxel.userData.body) {
                            voxel.position.copy(voxel.userData.body.position);
                            voxel.quaternion.copy(voxel.userData.body.quaternion);
                        }
                    });
                    
                    this.renderer.render(this.scene, this.camera);
                };
                
                animate();
            }
        }
        
        // Initialize debugger
        const debugger = new VoxelFlowerDebugger();
        
        // Run initial diagnostic
        setTimeout(() => debugger.runFullDiagnostic(), 1000);
    </script>
</body>
</html>